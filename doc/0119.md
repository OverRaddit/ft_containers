## 15:40 ~ 16:10 스프린트1
> 목표
- iter, const_iter를 따로? 왜왜?
> 결과
- 현재 iter, const iter, const_iter의 차이에 대해 정리했다.
- iterator_traits에서 템플릿인자로 넘어오는 T에 대해서 포인터는 분리할 수 있지만 const에 대해서는 분리할 수 없다.
  - 왜?

## 16:30 ~ 17:00 스프린트2
> 목표
- iter, const_iter를 따로? 왜왜?
> 결과


### const_iter 클래스를 별도로 구현해야 하는 이유

iter<const T> 형식을 const_iter로 하면 2가지 문제가 발생한다.

1. 원소를 가리키는 포인터가 가리키는 대상을 바꿀수 없게된다.
   - const_iter가 const_reference를 반환하기 때문이다.


### const_iter, iter의 차이

- 성능차이는 없음
- const_iter
  - 가리키는 대상의 값을 바꾸지 못하게 할 때 사용한다.
  - const T* pointer와 같이 const value를 포인팅함.
    - const value를 포인팅하는 것 : const T* pointer
    - value를 const 포인팅하는 것 : T const* pointer
    - 둘 사이 표기법이 헷갈린다.
  - const value를 참조한다 : const T&

- T*
  - A non-const iterator to a non-const element.
  - Corresponds to std::vector<T>::iterator
- T* const <- 이 표기법 기억해둘것.
  - A const iterator to a non-const element.
  - Corresponds to const std::vector<T>::iterator
- const T*
  - A non-const iterator to a const element.
  - Corresponds to std::vector<T>::const_iterator

출처: https://stackoverflow.com/questions/5346890/what-is-the-difference-between-const-iterator-and-iterator

## const