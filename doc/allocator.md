# allocator를 왜 사용하나?


메모리를 동적 할당할 경우 uninitialized로 메모리를 allocate가능.
new 연산자는 메모리할당후 기본적으로 초기화를 해줌. -> 불필요한 오버헤드 발생.
	벡터가 new를 통해 생성된다고 가정...
	할당과 동시에 모든 요소들이 해당 클래스 타입에 맞게 기본생성자를 통해 초기화 된다.
	사용자는 이 벡터에 원하는 요소를 저장하게 되고 결국 2번씩 초기화 하는 셈이다.
	int a = 3; -> int a=0;a=3; 과 같이 작업하는 것임@!

allocator의 멤버함수를 이용하면 메모리의 할당 + uninitialized의 메모리 시작주소를 얻을수있다.
원래 uninitialized 메모리 공간에 객체/값 직접할당불가능하지만 allocator가 그걸 가능하게 해줌.

메모리 해제없이 생성한 객체들을 소멸시킬 수 있게 해줌
	메모리 재할당없이 allocate했던 초기상태로 만들 수 있다.
	new 연산자로 할당한 메모리공간은 delete시 해제된다.

할당받은 메모리 공간이 초기화 되었는지 아닌지 알 수 있는 방법을 제공한다.
-> 뭔지 모르겠는데...?

# 몰랐던점.

- allocate 함수의 매개변수 n은 바이트단위가 아닌 필요한 T 객체의 개수이다.
	- T타입 * 개수를 충분히 할당할 수 있는 공간을 만든다.
	- 충분히....?
		- 1바이트 타입이든 4바이트 타입이든 필요한 크기 + 4바이트만큼 할당해주는 것 같음.
		- 8 bytes * 5 + 4
		- 블로그 주인장의 디버그피셜.
- new방식보다 유연/세밀하게 컨트롤가능.
	- fine-grained?

출처: https://woo-dev.tistory.com/51
