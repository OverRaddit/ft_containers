# 오늘의 목표

- 모두의 코드 정독
  - 템플릿
    - 템플릿 특수화 : 일부 경우는 따로 처리한다.
    -
  - 템플릿 메타 프로그래밍
    - 타입이 아닌 템플릿 인자
    - 템플릿 메타 프로그래밍
    - using 키워드
    -
  - type_traits, SFINAE, enable_if


## 템플릿 메타 프로그래밍

>템플릿을 통해서 타입을 인자인것 처럼 사용하는 것을 일반화 프로그래밍이라고 한다.

- 다른 템플릿 인자로 인스턴스화 되었다면 두 클래스는 다른 클래스이다.
- typeid(Array<int,3>) 으로 확인 가능.


내가 기존에 알던 인스턴스화
class A{};
A my_variable;

class -> object

이번에 배운 인스턴스화
template<T>
class A{};

typedef A<int> INT_A;
INT_A my_variable;

template -> class -> object

이렇게 클래스를 객체로 인스턴스화시키는 것에 그치지 않고 템플릿에서 함수/클래스로 인스턴스화가 가능해짐.

여기서 클래스의 연산자를 오버로딩하는 것이 가능하다는 것은 우리가 이미 알고있다.

그런데 클래스를 클래스명으로만 쓰지않고! 템플릿의 인스턴스화한 형태로 표기할 수 있다는 것을 인지하자.

클래스간의 연산자 오버로딩이 가능하다면
템플릿간의 연산자 오버로딩도 가능하다.

### TMP

여태까지의 타입은 어떠한 객체에 무엇을 저장하느냐? 를 지정함.
타입 자체가 어떠한 값을 가지지는 않았다.
템플릿을 사용하면 객체를 생성하지 않더라도 타입에 어떠한 값을 부여할 수 있다.
또, 그 타입을 가지고 연산을 할 수 있다!!

타입은 컴파일 타임에 확정되어야 하므로 컴파일 타임에 모든 연산이 끝난다.
타입을 가지고 컴파일 타임에 생성되는 코드로 프로그래밍 하는 것을 *메타 프로그래밍*이라고 한다.
템플릿은 이 작업을 템플릿으로 하기 때문에 TMP라고 한다.

//### TMP를 왜 쓰는가?

템플릿 인자에 따라서 어떠한 타입이 달라질 수 있는 것을 의존 타입(dependent type) 이라고 부릅니다.


# 오늘의 교훈

c++에서 class와 struct의 차이
접근지시자를 명시하지 않는 멤버의 경우!
- class는 private
- struct는 public